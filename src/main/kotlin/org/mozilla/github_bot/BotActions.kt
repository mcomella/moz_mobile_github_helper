package org.mozilla.github_bot

import com.beust.klaxon.obj
import com.beust.klaxon.string
import okhttp3.HttpUrl

private const val BOT_MESSAGE_HEADER_SUFFIX = "generated by kotbot!*" // todo: name

object BotActions {

    internal const val BOT_PR_HEADER = "*Issue links $BOT_MESSAGE_HEADER_SUFFIX"

    // TODO: we want to do this for more than just opened.
    suspend fun linkOpenedPRToIssues(prURL: HttpUrl, commitsURL: HttpUrl, initialPRComment: String) {
        val github = GithubAPIv3("") // tODO: instance with oauth.
        val commitsJSON = github.getCommits(commitsURL) ?: run {
            // TODO:
            return
        }

        val commitMsgs = commitsJSON.mapNotNull { it?.obj("commit")?.string("message") }
        val issueNums = commitMsgs.mapNotNull { GithubCommits.extractIssueNumFromCommitMsg(it) }.toSortedSet() // unique.

        writeIssueNumsInPRComment(github, prURL, issueNums, initialPRComment) // todo: async? Will github allow?
        // API to get and set issues by # 2x per issue - big rate limit!
    }

    internal suspend fun writeIssueNumsInPRComment(
            github: GithubAPIv3, prURL: HttpUrl, issueNums: java.util.SortedSet<Long>, initialPRComment: String
    ) {
        fun logError(msg: String) = println("writeIssueNumsInPRComment :: $msg: ignoring for url '$prURL'")

        if (initialPRComment.contains(BOT_PR_HEADER)) {
            logError("Pull request initial comment already contains bot header")
            return
        } else if (issueNums.isEmpty()) {
            logError("Pull request does not contain issue numbers")
            return
        }

        val postfix = if (initialPRComment.isBlank()) "" else "\n\n---\n\n$initialPRComment"
        val commentToWrite = issueNums.joinToString(separator = "\n", prefix = BOT_PR_HEADER + '\n', postfix = postfix) {
            "- [ ] #$it"
        }
        github.updatePR(prURL, commentToWrite)
    }
}
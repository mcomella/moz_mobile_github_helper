package org.mozilla.github_bot

import com.beust.klaxon.obj
import com.beust.klaxon.string
import okhttp3.HttpUrl
import java.util.SortedSet

private const val BOT_MESSAGE_HEADER_SUFFIX = "generated by kotbot!**" // todo: name

object BotActions {

    internal const val BOT_PR_HEADER = "**Issues this PR addresses - $BOT_MESSAGE_HEADER_SUFFIX"
    internal const val BOT_ISSUE_HEADER = "**PRs open for this issue - $BOT_MESSAGE_HEADER_SUFFIX"

    // TODO: we want to do this for more than just opened.
    suspend fun linkOpenedPRToIssues(
            prURL: HttpUrl,
            commitsURL: HttpUrl,
            repo: RepoPath,
            prNumber: Long,
            initialPRComment: String
    ) {
        val github = GithubAPIv3("") // tODO: instance with oauth.
        val commitsJSON = github.getCommits(commitsURL) ?: run {
            // TODO:
            return
        }

        val commitMsgs = commitsJSON.mapNotNull { it?.obj("commit")?.string("message") }
        val issueNums = commitMsgs.mapNotNull { GithubCommits.extractIssueNumFromCommitMsg(it) }.toSortedSet()

        writeIssueNumsInPRComment(github, prURL, issueNums, initialPRComment) // todo: async? Will github allow?
        writePRNumInIssues(github, prNumber, issueNums, repo)
    }

    internal suspend fun writeIssueNumsInPRComment(
            github: GithubAPIv3, prURL: HttpUrl, issueNums: java.util.SortedSet<Long>, initialPRComment: String
    ) {
        fun logError(msg: String) = println("writeIssueNumsInPRComment :: $msg: ignoring for url '$prURL'")

        if (initialPRComment.contains(BOT_PR_HEADER)) {
            logError("Pull request initial comment already contains bot header")
            return
        } else if (issueNums.isEmpty()) {
            logError("Pull request does not contain issue numbers")
            return
        }

        val postfix = if (initialPRComment.isBlank()) "" else "\n\n---\n\n$initialPRComment"
        val commentToWrite = issueNums.joinToString(separator = "\n", prefix = BOT_PR_HEADER + '\n', postfix = postfix) {
            "- [ ] #$it"
        }
        github.updatePR(prURL, commentToWrite)
    }

    /**
     * @param issueNums issues numbers as a set to ensure uniqueness, sorted for reproducibility.
     */
    internal suspend fun writePRNumInIssues(
            github: GithubAPIv3, prNumber: Long, issueNums: SortedSet<Long>, repo: RepoPath
    ) {
        // todo: test (easier to do one at a time then?)
        for (issueNum in issueNums) { // todo: async? will github allow?
            fun logError(msg: String) = println("writePRNumInIssues :: $msg: ignoring for issue #$issueNum")

            val issueJSON = github.getIssue(issueNum, repo)
            val issueComment = issueJSON?.string("body")
            if (issueComment == null) {
                logError("Unable to get issue body")
                continue
            }

            val updatedComment = getUpdatedIssueCommentForPR(prNumber, issueComment)
            if (updatedComment == null) {
                logError("Unable to get updated comment. Existing comment: $issueComment")
                continue
            }

            github.updateIssue(issueNum, repo, updatedComment)
        }
    }

    internal fun getUpdatedIssueCommentForPR(number: Long, existingComment: String): String? {
        val (isMalformed, errMsg) = isExistingIssueCommentMalformed(existingComment)
        if (isMalformed) {
            println("getUpdatedIssueCommentForPR :: Issue #$number: $errMsg. Ignoring.")
            return null
        }

        // todo: breaks if 1) someone modifies the header or if 2) we change the header.
        return if (existingComment.trimStart().startsWith(BOT_ISSUE_HEADER)) {
            insertPRNumIntoExistingComment(number, existingComment)
        } else {
            val postfix = if (existingComment.isBlank()) "" else "\n\n---\n\n$existingComment"
            """
            |$BOT_ISSUE_HEADER
            |- [ ] #${number}${postfix}
            """.trimMargin()
        }
    }

    // todo: more rigorous - we may make assumptions about what the bottom looks like.
    private fun isExistingIssueCommentMalformed(existingComment: String): Pair<Boolean, String> {
        val hasIssueHeader = existingComment.contains(BOT_ISSUE_HEADER)
        val startsWithIssueHeader = existingComment.trimStart().startsWith(BOT_ISSUE_HEADER)
        if (hasIssueHeader && !startsWithIssueHeader) {
            return Pair(false, "Existing issue comment malformed: header is present but not at the start")
        }

        // todo: match each line, check for validity.
        val lines = existingComment.lines()
        if (lines[0] != BOT_ISSUE_HEADER) {

        }

        return Pair(true, "")
    }

    private val issueRegex = """- [ ] #([0-9]+)""".toRegex() // todo: move. caps?
    private fun insertPRNumIntoExistingComment(number: Long, existingComment: String): String {
        // todo: we can extract original commit message, issue numbers, and re-use code from getUpdatedIssueCommentForPR.
        val issueNumbers = existingComment.lines().mapNotNull { issueRegex.find(it)?.groupValues?.get(1)?.toLong() }

    }
}
